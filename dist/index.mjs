function a(...t){return t.filter(Boolean).join(":")}import{setTimeout as u}from"timers/promises";var d=async(t,i)=>(await t.incr(`mq:${i}:count`)).toString(),l=t=>{let i=new Map,s=t.redisClient.duplicate();return s.connect(),s.subscribe("mq",async m=>{let e=JSON.parse(m);if(e.name===t.name&&e.event==="start"){let n=i.get(e.id);n&&((n.minTime??t.globalMinTime)&&await u(n.minTime??t.globalMinTime),n.func().finally(()=>{t.redisClient.publish("mq",JSON.stringify({...e,event:"finish"}))}),i.delete(e.id))}}),{add:async(m,e)=>{let n=await d(t.redisClient,t.name);return await t.redisClient.rPush(a("mq",t.name,e?.groupName,"wait"),n),new Promise((o,r)=>{i.set(n.toString(),{func:async()=>o(await m().catch(r)),minTime:e?.minTime}),t.redisClient.publish("mq",JSON.stringify({event:"add",name:t.name,groupName:e?.groupName,id:n}))})}}};import{Queue as f}from"async-await-queue";var g=t=>{let i=t.redisClient,s=new f(1),c=i.duplicate();c.connect(),c.subscribe("mq",async m=>{let e=JSON.parse(m);s.run(async()=>{if(e.event==="add"){let n=a("mq",e.name,e.groupName,"active"),o=a("mq",e.name,e.groupName,"wait");if(await i.lLen(n))return;await i.lRem(o,1,e.id),await i.rPush(n,e.id),await i.publish("mq",JSON.stringify({...e,event:"start"}))}if(e.event==="finish"){let n=a("mq",e.name,e.groupName,"active");await i.lRem(n,1,e.id);let o=a("mq",e.name,e.groupName,"wait"),r=await i.lPop(o);r&&(await i.rPush(n,r),await i.publish("mq",JSON.stringify({...e,id:r,event:"start"})))}})})};export{l as createQueue,g as createQueueProcessor};
//# sourceMappingURL=index.mjs.map