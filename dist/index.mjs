function a(...t){return t.filter(Boolean).join(":")}var m=async(t,i)=>(await t.incr(`mq:${i}:count`)).toString(),d=t=>{let i=new Map,r=t.redisClient.duplicate();return r.connect(),r.subscribe("mq",s=>{let e=JSON.parse(s);if(e.name===t.name&&e.event==="start"){let n=i.get(e.id);n&&(n().finally(()=>{t.redisClient.publish("mq",JSON.stringify({...e,event:"finish"}))}),i.delete(e.id))}}),{add:async(s,e)=>{let n=await m(t.redisClient,t.name);return await t.redisClient.rPush(a("mq",t.name,e?.groupName,"wait"),n),new Promise((o,c)=>{i.set(n.toString(),async()=>o(await s())),t.redisClient.publish("mq",JSON.stringify({event:"add",name:t.name,groupName:e?.groupName,id:n}))})}}};import{Queue as l}from"async-await-queue";var f=t=>{let i=t.redisClient,r=new l(1),u=i.duplicate();u.connect(),u.subscribe("mq",async s=>{let e=JSON.parse(s);r.run(async()=>{if(e.event==="add"){let n=a("mq",e.name,e.groupName,"active"),o=a("mq",e.name,e.groupName,"wait");if(await i.lLen(n))return;await i.lRem(o,1,e.id),await i.rPush(n,e.id),await i.publish("mq",JSON.stringify({...e,event:"start"}))}if(e.event==="finish"){let n=a("mq",e.name,e.groupName,"active");await i.lRem(n,1,e.id);let o=a("mq",e.name,e.groupName,"wait"),c=await i.lPop(o);c&&(await i.rPush(n,c),await i.publish("mq",JSON.stringify({...e,id:c,event:"start"})))}})})};export{d as createQueue,f as createQueueProcessor};
//# sourceMappingURL=index.mjs.map