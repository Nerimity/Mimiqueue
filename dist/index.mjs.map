{"version":3,"sources":["../src/utils.ts","../src/createQueue.ts","../src/createQueueProcessor.ts"],"sourcesContent":["export function makeKey(...args: any[]) {\r\n  return args.filter(Boolean).join(\":\");\r\n}\r\n","import { AddEvent, RedisClient } from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\n\r\ninterface createQueueOpts<T = () => any> {\r\n  redisClient: RedisClient;\r\n  name: string;\r\n}\r\n\r\ninterface AddOpts {\r\n  groupName?: string;\r\n}\r\n\r\nconst generateId = async (redisClient: RedisClient, name?: string) => {\r\n  const id = await redisClient.incr(`mq:${name}:count`);\r\n  return id.toString();\r\n};\r\n\r\nexport const createQueue = (opts: createQueueOpts) => {\r\n  const localWaitList = new Map<string, any>();\r\n\r\n  const sub = opts.redisClient.duplicate();\r\n  const pub = opts.redisClient.duplicate();\r\n\r\n  sub.subscribe(\"mq\", (message) => {\r\n    console.log(message);\r\n  });\r\n\r\n  const add = async <T extends () => any>(func: T, addOpts?: AddOpts) => {\r\n    if (!sub.isOpen) {\r\n      await sub.connect();\r\n    }\r\n    if (!pub.isOpen) {\r\n      await pub.connect();\r\n    }\r\n    const id = await generateId(pub, opts.name);\r\n\r\n    await pub.sAdd(makeKey(\"mq\", opts.name, addOpts?.groupName, \"wait\"), id);\r\n\r\n    return new Promise<Awaited<ReturnType<T>>>((resolve, reject) => {\r\n      localWaitList.set(id.toString(), () => resolve(func()));\r\n      pub.publish(\r\n        \"mq\",\r\n        JSON.stringify({\r\n          event: \"add\",\r\n          name: opts.name,\r\n          groupName: addOpts?.groupName,\r\n          id,\r\n        } as AddEvent)\r\n      );\r\n    });\r\n  };\r\n\r\n  return {\r\n    add,\r\n  };\r\n};\r\n","import { RedisClient, Event } from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\n\r\ninterface CreateQueueProcessorOpts {\r\n  redisClient: RedisClient;\r\n}\r\n/**\r\n *  This function should be ran in the main thread.\r\n *\r\n */\r\nexport const createQueueProcessor = (opts: CreateQueueProcessorOpts) => {\r\n  const redisClient = opts.redisClient;\r\n\r\n  redisClient.subscribe(\"mq\", (message) => {\r\n    const payload = JSON.parse(message) as Event;\r\n    if (payload.event === \"add\") {\r\n      const key = makeKey(\"mq\", payload.name, payload.groupName, \"active\");\r\n\r\n      redisClient.sAdd(key, payload.id);\r\n    }\r\n  });\r\n};\r\n"],"mappings":"AAAO,SAASA,KAAWC,EAAa,CACtC,OAAOA,EAAK,OAAO,OAAO,EAAE,KAAK,GAAG,CACtC,CCUA,IAAMC,EAAa,MAAOC,EAA0BC,KACvC,MAAMD,EAAY,KAAK,MAAMC,CAAI,QAAQ,GAC1C,SAAS,EAGRC,EAAeC,GAA0B,CACpD,IAAMC,EAAgB,IAAI,IAEpBC,EAAMF,EAAK,YAAY,UAAU,EACjCG,EAAMH,EAAK,YAAY,UAAU,EAEvC,OAAAE,EAAI,UAAU,KAAOE,GAAY,CAC/B,QAAQ,IAAIA,CAAO,CACrB,CAAC,EA2BM,CACL,IA1BU,MAA4BC,EAASC,IAAsB,CAChEJ,EAAI,QACP,MAAMA,EAAI,QAAQ,EAEfC,EAAI,QACP,MAAMA,EAAI,QAAQ,EAEpB,IAAMI,EAAK,MAAMX,EAAWO,EAAKH,EAAK,IAAI,EAE1C,aAAMG,EAAI,KAAKK,EAAQ,KAAMR,EAAK,KAAMM,GAAS,UAAW,MAAM,EAAGC,CAAE,EAEhE,IAAI,QAAgC,CAACE,EAASC,IAAW,CAC9DT,EAAc,IAAIM,EAAG,SAAS,EAAG,IAAME,EAAQJ,EAAK,CAAC,CAAC,EACtDF,EAAI,QACF,KACA,KAAK,UAAU,CACb,MAAO,MACP,KAAMH,EAAK,KACX,UAAWM,GAAS,UACpB,GAAAC,CACF,CAAa,CACf,CACF,CAAC,CACH,CAIA,CACF,EC7CO,IAAMI,EAAwBC,GAAmC,CACtE,IAAMC,EAAcD,EAAK,YAEzBC,EAAY,UAAU,KAAOC,GAAY,CACvC,IAAMC,EAAU,KAAK,MAAMD,CAAO,EAClC,GAAIC,EAAQ,QAAU,MAAO,CAC3B,IAAMC,EAAMC,EAAQ,KAAMF,EAAQ,KAAMA,EAAQ,UAAW,QAAQ,EAEnEF,EAAY,KAAKG,EAAKD,EAAQ,EAAE,CAClC,CACF,CAAC,CACH","names":["makeKey","args","generateId","redisClient","name","createQueue","opts","localWaitList","sub","pub","message","func","addOpts","id","makeKey","resolve","reject","createQueueProcessor","opts","redisClient","message","payload","key","makeKey"]}