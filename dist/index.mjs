function s(...t){return t.filter(Boolean).join(":")}var f=async(t,i)=>(await t.incr(`mq:${i}:count`)).toString(),p=async t=>{t.redisClient.publish("mq",JSON.stringify({event:"options",name:t.name,minTime:t.minTime}));let i=new Map,a=t.redisClient.duplicate();return await a.connect(),await a.subscribe("mq",async m=>{let e=JSON.parse(m);if(e.name===t.name&&e.event==="start"){let n=i.get(e.id);n&&(n.func().finally(()=>{t.redisClient.publish("mq",JSON.stringify({...e,event:"finish"}))}),i.delete(e.id))}}),{add:async(m,e)=>{let n=await f(t.redisClient,t.name);return await t.redisClient.rPush(s("mq",t.name,e?.groupName,"wait"),n),new Promise((o,r)=>{i.set(n.toString(),{func:async()=>o(await m().catch(r))}),t.redisClient.publish("mq",JSON.stringify({event:"add",name:t.name,groupName:e?.groupName,id:n}))})}}};import{Queue as v}from"async-await-queue";import{setTimeout as l}from"timers/promises";var y=async t=>{let i=t.redisClient,a=new Map,c=i.duplicate();await c.connect(),await c.subscribe("mq",async m=>{let e=JSON.parse(m);if(e.event==="options"){if(a.has(e.name))return;a.set(e.name,{minTime:e.minTime,localQueue:new v(1)});return}let n=a.get(e.name),o=n?.localQueue;!n||!o||o.run(async()=>{if(e.event==="add"){let r=s("mq",e.name,e.groupName,"active"),d=s("mq",e.name,e.groupName,"wait");if(await i.lLen(r))return;await i.lRem(d,1,e.id),await i.rPush(r,e.id),n.minTime&&await l(n.minTime),i.publish("mq",JSON.stringify({...e,event:"start"}))}if(e.event==="finish"){let r=s("mq",e.name,e.groupName,"active");await i.lRem(r,1,e.id);let d=s("mq",e.name,e.groupName,"wait"),u=await i.lPop(d);u&&(await i.rPush(r,u),n.minTime&&await l(n.minTime),i.publish("mq",JSON.stringify({...e,id:u,event:"start"})))}})})};export{p as createQueue,y as createQueueProcessor};
//# sourceMappingURL=index.mjs.map