{"version":3,"sources":["../src/utils.ts","../src/createQueue.ts","../src/createQueueProcessor.ts"],"sourcesContent":["export function makeKey(...args: any[]) {\r\n  return args.filter(Boolean).join(\":\");\r\n}\r\n","import {\r\n  AddEvent,\r\n  Event,\r\n  FinishEvent,\r\n  OptionsEvent,\r\n  RedisClient,\r\n} from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\ninterface createQueueOpts<T = () => any> {\r\n  redisClient: RedisClient;\r\n  name: string;\r\n  minTime?: number;\r\n}\r\n\r\ninterface AddOpts {\r\n  groupName?: string;\r\n}\r\n\r\ninterface WaitList {\r\n  func: () => Promise<any>;\r\n}\r\n\r\nconst generateId = async (redisClient: RedisClient, name?: string) => {\r\n  const id = await redisClient.incr(`mq:${name}:count`);\r\n  return id.toString();\r\n};\r\n\r\nexport const createQueue = async (opts: createQueueOpts) => {\r\n  opts.redisClient.publish(\r\n    \"mq\",\r\n    JSON.stringify({\r\n      event: \"options\",\r\n      name: opts.name,\r\n      minTime: opts.minTime,\r\n    } as OptionsEvent)\r\n  );\r\n\r\n  const localWaitList = new Map<string, WaitList>();\r\n\r\n  const sub = opts.redisClient.duplicate();\r\n  await sub.connect();\r\n\r\n  await sub.subscribe(\"mq\", async (message) => {\r\n    const payload = JSON.parse(message) as Event;\r\n    if (payload.name !== opts.name) {\r\n      return;\r\n    }\r\n    if (payload.event === \"start\") {\r\n      const waitListItem = localWaitList.get(payload.id);\r\n      if (waitListItem) {\r\n        waitListItem.func().finally(() => {\r\n          opts.redisClient.publish(\r\n            \"mq\",\r\n            JSON.stringify({ ...payload, event: \"finish\" } as FinishEvent)\r\n          );\r\n        });\r\n        localWaitList.delete(payload.id);\r\n      }\r\n    }\r\n  });\r\n\r\n  const add = async <T extends () => any>(func: T, addOpts?: AddOpts) => {\r\n    const id = await generateId(opts.redisClient, opts.name);\r\n\r\n    await opts.redisClient.rPush(\r\n      makeKey(\"mq\", opts.name, addOpts?.groupName, \"wait\"),\r\n      id\r\n    );\r\n\r\n    return new Promise<Awaited<ReturnType<T>>>((resolve, reject) => {\r\n      localWaitList.set(id.toString(), {\r\n        func: async () => resolve(await func().catch(reject)),\r\n      });\r\n      opts.redisClient.publish(\r\n        \"mq\",\r\n        JSON.stringify({\r\n          event: \"add\",\r\n          name: opts.name,\r\n          groupName: addOpts?.groupName,\r\n          id,\r\n        } as AddEvent)\r\n      );\r\n    });\r\n  };\r\n\r\n  return {\r\n    add,\r\n  };\r\n};\r\n","import { Queue } from \"async-await-queue\";\r\nimport { RedisClient, Event, StartEvent } from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\nimport { setTimeout } from \"timers/promises\";\r\n\r\ninterface CreateQueueProcessorOpts {\r\n  redisClient: RedisClient;\r\n}\r\n\r\ninterface QueueOption {\r\n  minTime?: number;\r\n  localQueue: Queue;\r\n}\r\n/**\r\n *  This function should be ran in the main thread.\r\n *\r\n */\r\nexport const createQueueProcessor = async (opts: CreateQueueProcessorOpts) => {\r\n  const redisClient = opts.redisClient;\r\n  const queueOptions: Map<string, QueueOption> = new Map();\r\n\r\n  const sub = redisClient.duplicate();\r\n  await sub.connect();\r\n\r\n  await sub.subscribe(\"mq\", async (message) => {\r\n    const payload = JSON.parse(message) as Event;\r\n\r\n    if (payload.event === \"options\") {\r\n      if (queueOptions.has(payload.name)) {\r\n        return;\r\n      }\r\n      queueOptions.set(payload.name, {\r\n        minTime: payload.minTime,\r\n        localQueue: new Queue(1),\r\n      });\r\n      return;\r\n    }\r\n    const options = queueOptions.get(payload.name);\r\n    const localQueue = options?.localQueue;\r\n\r\n    if (!options || !localQueue) {\r\n      return;\r\n    }\r\n\r\n    localQueue.run(async () => {\r\n      if (payload.event === \"add\") {\r\n        const activeKey = makeKey(\r\n          \"mq\",\r\n          payload.name,\r\n          payload.groupName,\r\n          \"active\"\r\n        );\r\n        const waitKey = makeKey(\"mq\", payload.name, payload.groupName, \"wait\");\r\n\r\n        const activeEntriesLength = await redisClient.lLen(activeKey);\r\n        if (activeEntriesLength) {\r\n          return;\r\n        }\r\n\r\n        await redisClient.lRem(waitKey, 1, payload.id);\r\n        await redisClient.rPush(activeKey, payload.id);\r\n        if (options.minTime) {\r\n          await setTimeout(options.minTime);\r\n        }\r\n        redisClient.publish(\r\n          \"mq\",\r\n          JSON.stringify({ ...payload, event: \"start\" } as StartEvent)\r\n        );\r\n      }\r\n\r\n      if (payload.event === \"finish\") {\r\n        const activeKey = makeKey(\r\n          \"mq\",\r\n          payload.name,\r\n          payload.groupName,\r\n          \"active\"\r\n        );\r\n        await redisClient.lRem(activeKey, 1, payload.id);\r\n\r\n        const waitKey = makeKey(\"mq\", payload.name, payload.groupName, \"wait\");\r\n\r\n        const firstWaitingId = await redisClient.lPop(waitKey);\r\n\r\n        if (firstWaitingId) {\r\n          await redisClient.rPush(activeKey, firstWaitingId);\r\n          if (options.minTime) {\r\n            await setTimeout(options.minTime);\r\n          }\r\n          redisClient.publish(\r\n            \"mq\",\r\n            JSON.stringify({\r\n              ...payload,\r\n              id: firstWaitingId,\r\n              event: \"start\",\r\n            } as StartEvent)\r\n          );\r\n        }\r\n      }\r\n    });\r\n  });\r\n};\r\n"],"mappings":"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","names":["makeKey","args","generateId","redisClient","name","createQueue","opts","localWaitList","sub","message","payload","waitListItem","func","addOpts","id","makeKey","resolve","reject","Queue","setTimeout","createQueueProcessor","opts","redisClient","queueOptions","sub","message","payload","Queue","options","localQueue","activeKey","makeKey","waitKey","firstWaitingId"]}