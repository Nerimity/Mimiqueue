function s(...e){return e.filter(Boolean).join(":")}var p=async(e,n,m)=>(await e.incr(s(`mq${m}`,n,"count"))).toString(),g=e=>{e.prefix?e.prefix=`-${e.prefix}`:e.prefix="";let n=new Map,m=async()=>await p(e.redisClient,e.name),u=async(a,t,r)=>await e.redisClient.lPos(s(`mq${r}`,e.name,t,"wait"),a),c=e.redisClient.duplicate(),f=e.redisClient.duplicate();return f.connect(),c.connect().then(()=>{e.redisClient.publish(`mq${e.prefix}`,JSON.stringify({event:"options",name:e.name,minTime:e.minTime}))}),f.subscribe(`mq${e.prefix}`,async a=>{let t=JSON.parse(a);if(t.name===e.name&&t.event==="start"){let r=n.get(t.id);r&&(r.func().finally(()=>{e.redisClient.publish(`mq${e.prefix}`,JSON.stringify({...t,event:"finish"}))}),n.delete(t.id))}}),{add:async(a,t)=>{let r=t?.id||await m();return await e.redisClient.rPush(s(`mq${e.prefix}`,e.name,t?.groupName,"wait"),r),new Promise((l,o)=>{n.set(r.toString(),{func:async()=>l(await a().catch(o))}),e.redisClient.publish(`mq${e.prefix}`,JSON.stringify({event:"add",name:e.name,groupName:t?.groupName,id:r}))})},genId:m,getQueuePosition:u}};import{Queue as y}from"async-await-queue";import{setTimeout as d}from"timers/promises";var w=async e=>{e.prefix?e.prefix=`-${e.prefix}`:e.prefix="";let n=e.redisClient,m=new Map,u=n.duplicate();await u.connect();let c=[];for await(let f of u.scanIterator({MATCH:`mq${e.prefix}:*`}))c.push(f);c.length&&(await n.del(c),c=[]),await u.subscribe(`mq${e.prefix}`,async f=>{let i=JSON.parse(f);if(i.event==="options"){if(m.has(i.name))return;m.set(i.name,{minTime:i.minTime,localQueue:new y(1)});return}let a=m.get(i.name),t=a?.localQueue;!a||!t||t.run(async()=>{if(i.event==="add"){let r=s(`mq${e.prefix}`,i.name,i.groupName,"active"),l=s(`mq${e.prefix}`,i.name,i.groupName,"wait");if(await n.lLen(r))return;await n.lRem(l,1,i.id),await n.rPush(r,i.id),a.minTime&&await d(a.minTime),n.publish(`mq${e.prefix}`,JSON.stringify({...i,event:"start"}))}if(i.event==="finish"){let r=s(`mq${e.prefix}`,i.name,i.groupName,"active");await n.lRem(r,1,i.id);let l=s(`mq${e.prefix}`,i.name,i.groupName,"wait"),o=await n.lPop(l);o&&(await n.rPush(r,o),a.minTime&&await d(a.minTime),n.publish(`mq${e.prefix}`,JSON.stringify({...i,id:o,event:"start"})))}})})};export{g as createQueue,w as createQueueProcessor};
//# sourceMappingURL=index.mjs.map