{"version":3,"sources":["../src/utils.ts","../src/createQueue.ts","../src/createQueueProcessor.ts"],"sourcesContent":["export function makeKey(...args: any[]) {\r\n  return args.filter(Boolean).join(\":\");\r\n}\r\n","import {\r\n  AddEvent,\r\n  Event,\r\n  FinishEvent,\r\n  OptionsEvent,\r\n  RedisClient,\r\n} from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\ninterface createQueueOpts<T = () => any> {\r\n  prefix?: string;\r\n  redisClient: RedisClient;\r\n  name: string;\r\n  minTime?: number;\r\n}\r\n\r\ninterface AddOpts {\r\n  groupName?: string;\r\n  id?: string;\r\n}\r\n\r\ninterface WaitList {\r\n  func: () => Promise<any>;\r\n}\r\n\r\nconst generateId = async (\r\n  redisClient: RedisClient,\r\n  name?: string,\r\n  prefix?: string\r\n) => {\r\n  const id = await redisClient.incr(makeKey(`mq${prefix}`, name, \"count\"));\r\n  return id.toString();\r\n};\r\n\r\nexport const createQueue = (opts: createQueueOpts) => {\r\n  if (opts.prefix) {\r\n    opts.prefix = `-${opts.prefix}`;\r\n  } else {\r\n    opts.prefix = \"\";\r\n  }\r\n  const localWaitList = new Map<string, WaitList>();\r\n\r\n  const genId = async () => {\r\n    return await generateId(opts.redisClient, opts.name);\r\n  };\r\n\r\n  const getQueuePosition = async (\r\n    id: string,\r\n    groupName?: string,\r\n    prefix?: string\r\n  ) => {\r\n    return await opts.redisClient.lPos(\r\n      makeKey(`mq${prefix}`, opts.name, groupName, \"wait\"),\r\n      id\r\n    );\r\n  };\r\n\r\n  const pub = opts.redisClient.duplicate();\r\n  const sub = opts.redisClient.duplicate();\r\n  sub.connect();\r\n  pub.connect().then(() => {\r\n    opts.redisClient.publish(\r\n      `mq${opts.prefix}`,\r\n      JSON.stringify({\r\n        event: \"options\",\r\n        name: opts.name,\r\n        minTime: opts.minTime,\r\n      } as OptionsEvent)\r\n    );\r\n  });\r\n\r\n  sub.subscribe(`mq${opts.prefix}`, async (message) => {\r\n    const payload = JSON.parse(message) as Event;\r\n    if (payload.name !== opts.name) {\r\n      return;\r\n    }\r\n    if (payload.event === \"start\") {\r\n      const waitListItem = localWaitList.get(payload.id);\r\n      if (waitListItem) {\r\n        waitListItem.func().finally(() => {\r\n          opts.redisClient.publish(\r\n            `mq${opts.prefix}`,\r\n            JSON.stringify({ ...payload, event: \"finish\" } as FinishEvent)\r\n          );\r\n        });\r\n        localWaitList.delete(payload.id);\r\n      }\r\n    }\r\n  });\r\n\r\n  const add = async <T extends () => any>(func: T, addOpts?: AddOpts) => {\r\n    const id = addOpts?.id || (await genId());\r\n\r\n    await opts.redisClient.rPush(\r\n      makeKey(`mq${opts.prefix}`, opts.name, addOpts?.groupName, \"wait\"),\r\n      id\r\n    );\r\n\r\n    return new Promise<Awaited<ReturnType<T>>>((resolve, reject) => {\r\n      localWaitList.set(id.toString(), {\r\n        func: async () => resolve(await func().catch(reject)),\r\n      });\r\n      opts.redisClient.publish(\r\n        `mq${opts.prefix}`,\r\n        JSON.stringify({\r\n          event: \"add\",\r\n          name: opts.name,\r\n          groupName: addOpts?.groupName,\r\n          id,\r\n        } as AddEvent)\r\n      );\r\n    });\r\n  };\r\n\r\n  return {\r\n    add,\r\n    genId,\r\n    getQueuePosition,\r\n  };\r\n};\r\n","import { Queue } from \"async-await-queue\";\r\nimport { RedisClient, Event, StartEvent } from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\nimport { setTimeout } from \"timers/promises\";\r\n\r\ninterface CreateQueueProcessorOpts {\r\n  prefix?: string;\r\n  redisClient: RedisClient;\r\n}\r\n\r\ninterface QueueOption {\r\n  minTime?: number;\r\n  localQueue: Queue;\r\n}\r\n/**\r\n *  This function should be ran in the main thread.\r\n *\r\n */\r\nexport const createQueueProcessor = async (opts: CreateQueueProcessorOpts) => {\r\n  if (opts.prefix) {\r\n    opts.prefix = `-${opts.prefix}`;\r\n  } else {\r\n    opts.prefix = \"\";\r\n  }\r\n  const redisClient = opts.redisClient;\r\n  const queueOptions: Map<string, QueueOption> = new Map();\r\n\r\n  const sub = redisClient.duplicate();\r\n  await sub.connect();\r\n\r\n  let keysToDelete = [];\r\n  for await (const key of sub.scanIterator({\r\n    MATCH: `mq${opts.prefix}:*`,\r\n  })) {\r\n    keysToDelete.push(key);\r\n  }\r\n  if (keysToDelete.length) {\r\n    await redisClient.del(keysToDelete);\r\n    keysToDelete = [];\r\n  }\r\n\r\n  await sub.subscribe(`mq${opts.prefix}`, async (message) => {\r\n    const payload = JSON.parse(message) as Event;\r\n\r\n    if (payload.event === \"options\") {\r\n      if (queueOptions.has(payload.name)) {\r\n        return;\r\n      }\r\n      queueOptions.set(payload.name, {\r\n        minTime: payload.minTime,\r\n        localQueue: new Queue(1),\r\n      });\r\n      return;\r\n    }\r\n    const options = queueOptions.get(payload.name);\r\n    const localQueue = options?.localQueue;\r\n\r\n    if (!options || !localQueue) {\r\n      return;\r\n    }\r\n\r\n    localQueue.run(async () => {\r\n      if (payload.event === \"add\") {\r\n        const activeKey = makeKey(\r\n          `mq${opts.prefix}`,\r\n          payload.name,\r\n          payload.groupName,\r\n          \"active\"\r\n        );\r\n        const waitKey = makeKey(\r\n          `mq${opts.prefix}`,\r\n          payload.name,\r\n          payload.groupName,\r\n          \"wait\"\r\n        );\r\n\r\n        const activeEntriesLength = await redisClient.lLen(activeKey);\r\n        if (activeEntriesLength) {\r\n          return;\r\n        }\r\n\r\n        await redisClient.lRem(waitKey, 1, payload.id);\r\n        await redisClient.rPush(activeKey, payload.id);\r\n        if (options.minTime) {\r\n          await setTimeout(options.minTime);\r\n        }\r\n        redisClient.publish(\r\n          `mq${opts.prefix}`,\r\n          JSON.stringify({ ...payload, event: \"start\" } as StartEvent)\r\n        );\r\n      }\r\n\r\n      if (payload.event === \"finish\") {\r\n        const activeKey = makeKey(\r\n          `mq${opts.prefix}`,\r\n          payload.name,\r\n          payload.groupName,\r\n          \"active\"\r\n        );\r\n        await redisClient.lRem(activeKey, 1, payload.id);\r\n\r\n        const waitKey = makeKey(\r\n          `mq${opts.prefix}`,\r\n          payload.name,\r\n          payload.groupName,\r\n          \"wait\"\r\n        );\r\n\r\n        const firstWaitingId = await redisClient.lPop(waitKey);\r\n\r\n        if (firstWaitingId) {\r\n          await redisClient.rPush(activeKey, firstWaitingId);\r\n          if (options.minTime) {\r\n            await setTimeout(options.minTime);\r\n          }\r\n          redisClient.publish(\r\n            `mq${opts.prefix}`,\r\n            JSON.stringify({\r\n              ...payload,\r\n              id: firstWaitingId,\r\n              event: \"start\",\r\n            } as StartEvent)\r\n          );\r\n        }\r\n      }\r\n    });\r\n  });\r\n};\r\n"],"mappings":"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","names":["makeKey","args","generateId","redisClient","name","prefix","makeKey","createQueue","opts","localWaitList","genId","getQueuePosition","id","groupName","pub","sub","message","payload","waitListItem","func","addOpts","resolve","reject","Queue","setTimeout","createQueueProcessor","opts","redisClient","queueOptions","sub","keysToDelete","key","message","payload","Queue","options","localQueue","activeKey","makeKey","waitKey","firstWaitingId"]}