function s(...t){return t.filter(Boolean).join(":")}var f=async(t,i)=>(await t.incr(`mq:${i}:count`)).toString(),p=t=>{let i=new Map,m=t.redisClient.duplicate(),o=t.redisClient.duplicate();return o.connect(),m.connect().then(()=>{t.redisClient.publish("mq",JSON.stringify({event:"options",name:t.name,minTime:t.minTime}))}),o.subscribe("mq",async e=>{let n=JSON.parse(e);if(n.name===t.name&&n.event==="start"){let a=i.get(n.id);a&&(a.func().finally(()=>{t.redisClient.publish("mq",JSON.stringify({...n,event:"finish"}))}),i.delete(n.id))}}),{add:async(e,n)=>{let a=await f(t.redisClient,t.name);return await t.redisClient.rPush(s("mq",t.name,n?.groupName,"wait"),a),new Promise((r,u)=>{i.set(a.toString(),{func:async()=>r(await e().catch(u))}),t.redisClient.publish("mq",JSON.stringify({event:"add",name:t.name,groupName:n?.groupName,id:a}))})}}};import{Queue as v}from"async-await-queue";import{setTimeout as l}from"timers/promises";var y=async t=>{let i=t.redisClient,m=new Map,o=i.duplicate();await o.connect(),await o.subscribe("mq",async d=>{let e=JSON.parse(d);if(e.event==="options"){if(m.has(e.name))return;m.set(e.name,{minTime:e.minTime,localQueue:new v(1)});return}let n=m.get(e.name),a=n?.localQueue;!n||!a||a.run(async()=>{if(e.event==="add"){let r=s("mq",e.name,e.groupName,"active"),u=s("mq",e.name,e.groupName,"wait");if(await i.lLen(r))return;await i.lRem(u,1,e.id),await i.rPush(r,e.id),n.minTime&&await l(n.minTime),i.publish("mq",JSON.stringify({...e,event:"start"}))}if(e.event==="finish"){let r=s("mq",e.name,e.groupName,"active");await i.lRem(r,1,e.id);let u=s("mq",e.name,e.groupName,"wait"),c=await i.lPop(u);c&&(await i.rPush(r,c),n.minTime&&await l(n.minTime),i.publish("mq",JSON.stringify({...e,id:c,event:"start"})))}})})};export{p as createQueue,y as createQueueProcessor};
//# sourceMappingURL=index.mjs.map