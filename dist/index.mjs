function a(...t){return t.filter(Boolean).join(":")}var m=async(t,i)=>(await t.incr(`mq:${i}:count`)).toString(),d=t=>{let i=new Map,s=t.redisClient.duplicate();return s.connect(),s.subscribe("mq",o=>{let e=JSON.parse(o);if(e.name===t.name&&e.event==="start"){let n=i.get(e.id);n&&(n().finally(()=>{t.redisClient.publish("mq",JSON.stringify({...e,event:"finish"}))}),i.delete(e.id))}}),{add:async(o,e)=>{let n=await m(t.redisClient,t.name);return await t.redisClient.rPush(a("mq",t.name,e?.groupName,"wait"),n),new Promise((c,r)=>{i.set(n.toString(),async()=>c(await o().catch(r))),t.redisClient.publish("mq",JSON.stringify({event:"add",name:t.name,groupName:e?.groupName,id:n}))})}}};import{Queue as l}from"async-await-queue";var f=t=>{let i=t.redisClient,s=new l(1),u=i.duplicate();u.connect(),u.subscribe("mq",async o=>{let e=JSON.parse(o);s.run(async()=>{if(e.event==="add"){let n=a("mq",e.name,e.groupName,"active"),c=a("mq",e.name,e.groupName,"wait");if(await i.lLen(n))return;await i.lRem(c,1,e.id),await i.rPush(n,e.id),await i.publish("mq",JSON.stringify({...e,event:"start"}))}if(e.event==="finish"){let n=a("mq",e.name,e.groupName,"active");await i.lRem(n,1,e.id);let c=a("mq",e.name,e.groupName,"wait"),r=await i.lPop(c);r&&(await i.rPush(n,r),await i.publish("mq",JSON.stringify({...e,id:r,event:"start"})))}})})};export{d as createQueue,f as createQueueProcessor};
//# sourceMappingURL=index.mjs.map