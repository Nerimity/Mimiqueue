{"version":3,"sources":["../src/utils.ts","../src/createQueue.ts","../src/createQueueProcessor.ts"],"sourcesContent":["export function makeKey(...args: any[]) {\r\n  return args.filter(Boolean).join(\":\");\r\n}\r\n","import { AddEvent, Event, FinishEvent, RedisClient } from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\nimport { setTimeout } from \"timers/promises\";\r\ninterface createQueueOpts<T = () => any> {\r\n  redisClient: RedisClient;\r\n  name: string;\r\n  globalMinTime?: number;\r\n}\r\n\r\ninterface AddOpts {\r\n  groupName?: string;\r\n  minTime?: number;\r\n}\r\n\r\ninterface WaitList {\r\n  func: () => Promise<any>;\r\n  minTime?: number;\r\n}\r\n\r\nconst generateId = async (redisClient: RedisClient, name?: string) => {\r\n  const id = await redisClient.incr(`mq:${name}:count`);\r\n  return id.toString();\r\n};\r\n\r\nexport const createQueue = (opts: createQueueOpts) => {\r\n  const localWaitList = new Map<string, WaitList>();\r\n\r\n  const sub = opts.redisClient.duplicate();\r\n  sub.connect();\r\n\r\n  sub.subscribe(\"mq\", async (message) => {\r\n    const payload = JSON.parse(message) as Event;\r\n    if (payload.name !== opts.name) {\r\n      return;\r\n    }\r\n    if (payload.event === \"start\") {\r\n      const waitListItem = localWaitList.get(payload.id);\r\n      if (waitListItem) {\r\n        if (waitListItem.minTime ?? opts.globalMinTime) {\r\n          await setTimeout(waitListItem.minTime ?? opts.globalMinTime);\r\n        }\r\n        waitListItem.func().finally(() => {\r\n          opts.redisClient.publish(\r\n            \"mq\",\r\n            JSON.stringify({ ...payload, event: \"finish\" } as FinishEvent)\r\n          );\r\n        });\r\n        localWaitList.delete(payload.id);\r\n      }\r\n    }\r\n  });\r\n\r\n  const add = async <T extends () => any>(func: T, addOpts?: AddOpts) => {\r\n    const id = await generateId(opts.redisClient, opts.name);\r\n\r\n    await opts.redisClient.rPush(\r\n      makeKey(\"mq\", opts.name, addOpts?.groupName, \"wait\"),\r\n      id\r\n    );\r\n\r\n    return new Promise<Awaited<ReturnType<T>>>((resolve, reject) => {\r\n      localWaitList.set(id.toString(), {\r\n        func: async () => resolve(await func().catch(reject)),\r\n        minTime: addOpts?.minTime,\r\n      });\r\n      opts.redisClient.publish(\r\n        \"mq\",\r\n        JSON.stringify({\r\n          event: \"add\",\r\n          name: opts.name,\r\n          groupName: addOpts?.groupName,\r\n          id,\r\n        } as AddEvent)\r\n      );\r\n    });\r\n  };\r\n\r\n  return {\r\n    add,\r\n  };\r\n};\r\n","import { Queue } from \"async-await-queue\";\r\nimport { RedisClient, Event, StartEvent } from \"./types\";\r\nimport { makeKey } from \"./utils\";\r\n\r\ninterface CreateQueueProcessorOpts {\r\n  redisClient: RedisClient;\r\n}\r\n/**\r\n *  This function should be ran in the main thread.\r\n *\r\n */\r\nexport const createQueueProcessor = (opts: CreateQueueProcessorOpts) => {\r\n  const redisClient = opts.redisClient;\r\n  const localQueue = new Queue(1);\r\n\r\n  const sub = redisClient.duplicate();\r\n  sub.connect();\r\n\r\n  sub.subscribe(\"mq\", async (message) => {\r\n    const payload = JSON.parse(message) as Event;\r\n\r\n    localQueue.run(async () => {\r\n      if (payload.event === \"add\") {\r\n        const activeKey = makeKey(\r\n          \"mq\",\r\n          payload.name,\r\n          payload.groupName,\r\n          \"active\"\r\n        );\r\n        const waitKey = makeKey(\"mq\", payload.name, payload.groupName, \"wait\");\r\n\r\n        const activeEntriesLength = await redisClient.lLen(activeKey);\r\n        if (activeEntriesLength) {\r\n          return;\r\n        }\r\n\r\n        await redisClient.lRem(waitKey, 1, payload.id);\r\n\r\n        await redisClient.rPush(activeKey, payload.id);\r\n\r\n        await redisClient.publish(\r\n          \"mq\",\r\n          JSON.stringify({ ...payload, event: \"start\" } as StartEvent)\r\n        );\r\n      }\r\n\r\n      if (payload.event === \"finish\") {\r\n        const activeKey = makeKey(\r\n          \"mq\",\r\n          payload.name,\r\n          payload.groupName,\r\n          \"active\"\r\n        );\r\n        await redisClient.lRem(activeKey, 1, payload.id);\r\n\r\n        const waitKey = makeKey(\"mq\", payload.name, payload.groupName, \"wait\");\r\n\r\n        const firstWaitingId = await redisClient.lPop(waitKey);\r\n\r\n        if (firstWaitingId) {\r\n          await redisClient.rPush(activeKey, firstWaitingId);\r\n          await redisClient.publish(\r\n            \"mq\",\r\n            JSON.stringify({\r\n              ...payload,\r\n              id: firstWaitingId,\r\n              event: \"start\",\r\n            } as StartEvent)\r\n          );\r\n        }\r\n      }\r\n    });\r\n  });\r\n};\r\n"],"mappings":"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","names":["makeKey","args","setTimeout","generateId","redisClient","name","createQueue","opts","localWaitList","sub","message","payload","waitListItem","func","addOpts","id","makeKey","resolve","reject","Queue","createQueueProcessor","opts","redisClient","localQueue","Queue","sub","message","payload","activeKey","makeKey","waitKey","firstWaitingId"]}